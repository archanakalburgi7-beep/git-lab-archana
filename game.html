<!DOCTYPE html>
<html lang="mr">
<head>
    <meta charset="UTF-8">
    <title>Realistic Bubble Shooter</title>
    <style>
        body {
            background: #e0e0e0; margin: 0; display: flex; flex-direction: column;
            align-items: center; justify-content: center; height: 100vh;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        .game-header {
            width: 440px; display: flex; justify-content: space-between;
            padding: 10px; background: #fff; border-radius: 10px 10px 0 0;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.05); border: 1px solid #ccc;
        }
        .canvas-container {
            position: relative; border: 8px solid #8d6e63; /* Wooden border */
            background: #f5f5f5; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-radius: 0 0 10px 10px;
        }
        canvas { display: block; cursor: crosshair; }
        .score { font-weight: bold; color: #333; font-size: 18px; }
        .back-btn {
            margin-top: 15px; text-decoration: none; color: #555;
            font-size: 14px; padding: 8px 20px; border: 1px solid #ccc;
            border-radius: 5px; background: #fff; transition: 0.2s;
        }
        .back-btn:hover { background: #eee; }
        
        /* Game Over Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; border-radius: 5px; z-index: 10;
        }
        #overlay button {
            margin-top: 15px; padding: 10px 25px; font-size: 18px;
            background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="game-header">
        <div class="score">Score: <span id="scoreVal">0</span></div>
        <div style="font-size: 14px; color: #666;">Realistic Mode</div>
    </div>

    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h1>GAME OVER!</h1>
            <p>तुमचे बबल्स रेषेच्या खाली आले आहेत.</p>
            <button onclick="resetGame()">Restart</button>
        </div>
    </div>

    <a href="dashboard.html" class="back-btn">← Back to Dashboard</a>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreVal');
    const overlay = document.getElementById('overlay');

    canvas.width = 440;
    canvas.height = 560;

    const bSize = 21; 
    const colors = ['#e53935', '#1e88e5', '#43a047', '#fdd835', '#8e24aa'];
    let score = 0;
    let grid = [];
    let projectile = null;
    let nextColor = colors[Math.floor(Math.random() * colors.length)];
    let mousePos = { x: canvas.width/2, y: 0 };
    let isGameOver = false;

    function initGrid() {
        grid = [];
        for (let r = 0; r < 14; r++) {
            grid[r] = [];
            let offset = (r % 2 === 0) ? 0 : bSize;
            for (let c = 0; c < 10; c++) {
                grid[r][c] = {
                    x: c * (bSize * 2) + bSize + offset,
                    y: r * (bSize * 1.8) + bSize + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    active: r < 4 
                };
            }
        }
    }

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', () => {
        if (projectile || isGameOver) return;
        const angle = Math.atan2(mousePos.y - (canvas.height - 40), mousePos.x - (canvas.width / 2));
        projectile = {
            x: canvas.width / 2, y: canvas.height - 40,
            color: nextColor,
            vx: Math.cos(angle) * 11, vy: Math.sin(angle) * 11
        };
        nextColor = colors[Math.floor(Math.random() * colors.length)];
    });

    function update() {
        if (isGameOver) return;

        if (projectile) {
            projectile.x += projectile.vx;
            projectile.y += projectile.vy;
            if (projectile.x < bSize || projectile.x > canvas.width - bSize) projectile.vx *= -1;

            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    let b = grid[r][c];
                    if (b.active && Math.hypot(projectile.x - b.x, projectile.y - b.y) < bSize * 1.8) {
                        lockAndPop(); return;
                    }
                }
            }
            if (projectile.y < bSize) lockAndPop();
        }

        // Out Condition: Check if any active bubble is too low
        grid.forEach(row => row.forEach(b => {
            if (b.active && b.y > canvas.height - 100) {
                isGameOver = true;
                overlay.style.display = 'flex';
            }
        }));
    }

    function lockAndPop() {
        let best = { r: 0, c: 0, d: 9999 };
        grid.forEach((row, r) => row.forEach((b, c) => {
            if (!b.active) {
                let d = Math.hypot(projectile.x - b.x, projectile.y - b.y);
                if (d < best.d) best = { r, c, d };
            }
        }));
        let target = grid[best.r][best.c];
        target.active = true; target.color = projectile.color;
        
        let matches = findMatches(best.r, best.c, target.color);
        if (matches.length >= 3) {
            matches.forEach(m => grid[m.r][m.c].active = false);
            score += matches.length * 10;
            scoreEl.innerText = score;
        }
        projectile = null;
    }

    function findMatches(r, c, color, matched = []) {
        let key = `${r}-${c}`;
        if (matched.includes(key)) return [];
        matched.push(key);
        let result = [{r, c}];
        let neighbors = [[-1,0], [1,0], [0,-1], [0,1]];
        if (r % 2 === 0) neighbors.push([-1,-1], [1,-1]); else neighbors.push([-1,1], [1,1]);
        neighbors.forEach(([dr, dc]) => {
            let nr = r + dr, nc = c + dc;
            if (grid[nr] && grid[nr][nc] && grid[nr][nc].active && grid[nr][nc].color === color) {
                result = result.concat(findMatches(nr, nc, color, matched));
            }
        });
        return result;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Limit Line (Out condition indicator)
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 100);
        ctx.lineTo(canvas.width, canvas.height - 100);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.2)";
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Aiming Line
        if (!projectile && !isGameOver) {
            ctx.beginPath();
            ctx.setLineDash([2, 4]);
            ctx.moveTo(canvas.width/2, canvas.height - 40);
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = "#999";
            ctx.stroke();
            ctx.setLineDash([]);
        }

        grid.forEach(row => row.forEach(b => b.active && drawBubble(b.x, b.y, b.color)));
        if (projectile) drawBubble(projectile.x, projectile.y, projectile.color);
        drawBubble(canvas.width / 2, canvas.height - 40, nextColor); 

        requestAnimationFrame(() => { update(); draw(); });
    }

    function drawBubble(x, y, color) {
        ctx.beginPath();
        ctx.arc(x, y, bSize - 1, 0, Math.PI * 2);
        let g = ctx.createRadialGradient(x-5, y-5, 2, x, y, bSize);
        g.addColorStop(0, '#fff'); g.addColorStop(0.4, color); g.addColorStop(1, '#333');
        ctx.fillStyle = g; ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.stroke();
    }

    function resetGame() {
        score = 0; scoreEl.innerText = 0;
        isGameOver = false; overlay.style.display = 'none';
        initGrid();
    }

    initGrid();
    draw();
</script>
</body>
</html>